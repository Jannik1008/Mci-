<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Reaction Time Experiment</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
<h1>Simple Reaction Time Experiment</h1>
<p id="endMessage" style="display: none;">Sie haben das Experiment beendet. Hier sind Ihre Ergebnisse.</p>
<p id="endMessage1" style="display: none;">Sie haben das Experiment beendet. Indem Sie 30 Versuche absolviert haben. Hier sind Ihre Ergebnisse.</p>
<p id="reactionTimeDisplay">Drücken Sie die Leertaste um das Experiment zu starten</p>
<p id="roundCounterDisplay">Durchlauf Nummer:</p><!-- Element zur Anzeige der Reaktionszeit -->
<p id="meanReactionTimeDisplay">Durchschnittliche Reaktionszeit</p> <!-- Element zur Anzeige des Durchschnitts der Reaktionszeit -->
<p id="standardabweichung">Standardabweichung</p> <!-- Element zur Anzeige des Durchschnitts der Reaktionszeit -->
<p id="errorCountDisplay">Fehler</p> <!-- Element zur Anzeige der Anzahl der Fehler -->
<p id="correlationDisplay">Korrelation</p> <!-- Element zur Anzeige der Anzahl der Fehler -->
<canvas id="canvas" width="1300" height="400"></canvas>


<script>

    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    var rectWidth = 100;
    var rectHeight = 50;
    var rectX, rectY;
    var bgColor = "#ffffff"; // Hintergrundfarbe
    var stimulusColor = "#ff0000"; // Stimulusfarbe
    var startTime, endTime;
    var reactionTimes = [];
    var distances = []; // Array zur Speicherung der Abstände
    var errors = 0;
    var totalReactions = -1;
    var stimulusDetected = false;
    var experimentRunning = false;
    var firstClickSkipped = false; // Variable zur Verfolgung des ersten Klicks

    // Funktion zur Berechnung der Korrelation

    function calculateCorrelation() {
        if (reactionTimes.length === 0 || distances.length === 0) {
            return "Nicht genügend Daten für die Korrelation.";
        }

        // Berechne den Durchschnitt der Reaktionszeiten
        let meanReactionTime = reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length;
        // Berechne den Durchschnitt der Abstände
        let meanDistance = distances.reduce((a, b) => a + b, 0) / distances.length;

        // Berechne die Standardabweichung der Reaktionszeiten und der Abstände
        let reactionTimeDeviation = Math.sqrt(reactionTimes.map(x => Math.pow(x - meanReactionTime, 2)).reduce((a, b) => a + b, 0) / reactionTimes.length);
        let distanceDeviation = Math.sqrt(distances.map(x => Math.pow(x - meanDistance, 2)).reduce((a, b) => a + b, 0) / distances.length);

        // Berechne die Kovarianz
        let covariance = 0;
        for (let i = 0; i < reactionTimes.length; i++) {
            covariance += (reactionTimes[i] - meanReactionTime) * (distances[i] - meanDistance);
        }
        covariance /= reactionTimes.length;

        // Berechne die Korrelation
        let correlation = covariance / (reactionTimeDeviation * distanceDeviation);

        return correlation;
    }

    function drawRectangle() {
        // Clear the canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Zufällige Position für das Rechteck
        rectX = Math.random() * (canvas.width - rectWidth);
        rectY = Math.random() * (canvas.height - rectHeight);

        // Zeichne das Rechteck mit der Hintergrundfarbe initial
        ctx.fillStyle = bgColor;
        ctx.fillRect(rectX, rectY, rectWidth, rectHeight);

        // Startzeit
        startTime = new Date().getTime();

        // Setze experimentRunning auf true
        experimentRunning = true;
        // Setze stimulusDetected auf false, um festzulegen, dass kein Rechteck angezeigt wurde
        stimulusDetected = false;
    }

    // Funktion zur Farbänderung des Rechtecks
    function changeColor(timestamp) {
        var currentTime = new Date().getTime();
        var elapsedTime = currentTime - startTime;
        var colorProgress = Math.min(1, elapsedTime / 3000); // Farbänderung über 3 Sekunden

        // Interpoliere Farbe zwischen Hintergrundfarbe und Stimulusfarbe
        var r = parseInt(bgColor.slice(1, 3), 16) * (1 - colorProgress) + parseInt(stimulusColor.slice(1, 3), 16) * colorProgress;
        var g = parseInt(bgColor.slice(3, 5), 16) * (1 - colorProgress) + parseInt(stimulusColor.slice(3, 5), 16) * colorProgress;
        var b = parseInt(bgColor.slice(5, 7), 16) * (1 - colorProgress) + parseInt(stimulusColor.slice(5, 7), 16) * colorProgress;
        var interpolatedColor = "#" + Math.round(r).toString(16).padStart(2, '0') +
            Math.round(g).toString(16).padStart(2, '0') +
            Math.round(b).toString(16).padStart(2, '0');

        // Zeichne das Rechteck mit interpolierter Farbe
        ctx.fillStyle = interpolatedColor;
        ctx.fillRect(rectX, rectY, rectWidth, rectHeight);

        // Überprüfe, ob Stimulus erkannt wurde
        if (!stimulusDetected) {
            stimulusDetected = true;
            let stimulusCenterX = rectX + rectWidth / 2;
            let screenWidth = canvas.width;
            let stimulusDistanceToCenter = Math.abs(stimulusCenterX - screenWidth / 2);
            distances.push(stimulusDistanceToCenter); // Speichere den Abstand zur Mitte
        }

        // Überprüfe, ob Zeitlimit für Reaktion erreicht wurde
        if (elapsedTime >= 6000 && experimentRunning) {
            // Keine Reaktion innerhalb des Zeitlimits
            errors++;
            drawRectangle();
            changeColor();
        } else {
            // Fortsetzen der Farbänderung des Rechtecks
            requestAnimationFrame(changeColor);
        }
    }

    function showResults() {
        // Endzeit und Berechnung der Reaktionszeit
        endTime = new Date().getTime();
        var reactionTime = endTime - startTime;
        reactionTimes.push(reactionTime);
        totalReactions++ ;

        let meanReactionTime = reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length;
        let stdDev = Math.sqrt(reactionTimes.map(x => Math.pow(x - meanReactionTime, 2)).reduce((a, b) => a + b, 0) / reactionTimes.length);

        // Berechne und zeige die Korrelation
        let correlation = calculateCorrelation();


        document.getElementById("reactionTimeDisplay").innerText = "Reaktionszeit: " + reactionTime + " Millisekunden";
        document.getElementById("roundCounterDisplay").innerText = "Durchlauf: " + totalReactions;
        document.getElementById("meanReactionTimeDisplay").innerText = "Durchschnittliche Reaktionszeit: " + meanReactionTime.toFixed(0) + " Millisekunden";
        document.getElementById("standardabweichung").innerText = "Standardabweichung: " + stdDev.toFixed(0) + " Millisekunden";
        document.getElementById("errorCountDisplay").innerText = "Fehler: " + errors;
        document.getElementById("correlationDisplay").innerText = "Korrelation: " + correlation.toFixed(2);

    }


    function stopExperiment() {
        // Stopp des Experiments
        experimentRunning = false;

        // Canvas löschen
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Leere die Arrays für Reaktionszeiten und Abstände
        reactionTimes = [];
        distances = [];

        // Setze die Anzahl der Fehler zurück
        errors = 0;
        totalReactions = -1;
    }

    // Event-Listener zum Starten und Beenden des Experiments
    document.addEventListener("keydown", function(event) {
        if (event.keyCode == 32 && !experimentRunning) { // Leertaste gedrückt und Experiment nicht aktiv
            drawRectangle();
            changeColor();
        }

        if (event.keyCode == 32 && experimentRunning) { // Leertaste gedrückt und Experiment aktiv
            showResults();
            drawRectangle();
            changeColor();
        }

        // Fehler zählen, wenn keine Stimulus erkannt wurde und Leertaste gedrückt wurde
        if (event.keyCode == 32 && !stimulusDetected && !experimentRunning && firstClickSkipped) {
            errors++;
            document.getElementById("errorCountDisplay").innerText = "Fehler: " + errors;
        }
        // Setze firstClickSkipped auf true, nachdem der erste Klick erfolgt ist
        if (event.keyCode == 32 && !firstClickSkipped) {
            firstClickSkipped = true;
        }

        if (event.key == 'a' && experimentRunning) {
            stopExperiment();
            document.getElementById("endMessage").style.display = "block"; // Zeige die Nachricht an
        }

        if (totalReactions == 30) {
            stopExperiment();
            document.getElementById("endMessage1").style.display = "block"; // Zeige die Nachricht an
        }
    });

</script>
</body>
</html>